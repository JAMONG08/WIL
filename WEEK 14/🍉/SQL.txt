파일과 DB
파일 : 문서, 영상, 이미지 등의 데이터
DB : 특정 기준에 맞춰 정리된 데이터의 집합. 넓은 의미의 데이터
SQL : Structured Query Language 구조화된 질의 언어
ORM은 object-relational의 줄인말로 언어마다 다른 ORM을 사용


Oracle
  성능이 좋고, 기능이 많은데 비싸다.
  대규모 데이터베이스를 지원한다.
  고성능 트랜잭션 처리를 제공하여 속도가 빠르다.
  SQL문을 실행하는 가장 효율적인 방법을 선택한다. 비용을 최소화하기 위해 테이블과 인덱스를 분석한다.

MySQL
    오픈 소스로 무료로 사용 가능하다.
    top n개의 레코드를 가지고 오는 케이스에 특화되어 있다.
  update 성능이 postgre보다 우수하다.
  Nested Loop Join만 지원한다
  복잡한 알고리즘은 가급적 지원하지 않는다.
  문자열 비교에서 대소 문자를 구분하지 않는다.
  간단한 처리 속도를 향상 시키는 것을 추구함
  간단한 데이터 트랜잭션을 위한 데이터베이스가 필요한 웹 기반 프로젝트에 널리 사용된다. 로드가 많거나 복잡한 쿼리는 성능이 저하된다.
  교육용 무료, 상업용 유료 

PostgreSQL  
  오픈 소스로 무료로 사용 가능하다.
  다양한 join 방법을 제공한다.
  update를 할 때, 과거 행을 삭제하고 변경된 데이터를 가진 새로운 행을 추가하는 형태라서 update가 느리다.
  처리 속도를 빠르게 하기 위해 여러 CPU를 활용하여 쿼리를 실행한다.
  데이터베이스 클러스터 백업 기능을 제공한다.
  읽기, 쓰기 속도가 중요하고 데이터를 검증해야 하는 대규모 시스템에서 널리 사용된다.
  빈번한 update 성격일 경우 성능, 불안정 하지만 insert 위주 성격일 경우에는 적합하다.
  복잡한 쿼리를 실행해야하는 시스템에서 가장 잘 사용 된다.
  동시성을 효율적으로 처리하여 매우 높은 수준의 동시성을 달성한다.

====================================
0. SQL vs NOSQL
SQL
  SQL은 Foreign Key등을 이용하여 같이 관계를 정의
  복잡한 쿼리나 리포트를 만들어내야 하는 경우
  높은 부하가 예상될 경우(딴딴함!)
NoSQL
  기존 SQL 서버의 복잡성과 용량을 해결하기 위해 탄생
  지속적으로 새로운 기능들이 추가되고 변경되어 데이터셋을 사전정의하기 힘든경우

1. 수직적 확장성 / 수평성 확장성 
  SQL
    Scale-up : 서버 한대 중심으로 확장
    스키마가 고정적(type이 정해짐)
    데이터 간의 관계를 정의
    단순히 데이터베이스 서버의 성능을 향상시키는 것 

  NOSQL
    scale-out : 여러 대의 서버를 중심으로 확장
    스키마 유동적
    데이터 간의 관계를 정의하지 않는 비정형 데이터
    더 많은 서버가 추가되고 데이터베이스가 전체적으로 분산됨을 의미

2.쿼리 언어 여부
  SQL 
      join이 자주 일어나는 경우 = 정형화된 데이터(쇼핑몰, 유저의 트랜직션과 결합하는 경우)
      관계를 맺고 있어서 조인문이 많은 복잡한 쿼리가 만들어질 수 있음
  NOSQL
      언제든지 저장된 데이터를 조정하고 새로운 필드 추가 가능
      데이터는 애플리케이션이 필요로 하는 형식으로 저장됨.
      테이블간 관계가 없어 복잡한 쿼리사용이 부적합함
      애플리케이션이 발생시키는 모든 읽기/쓰기 요청 처리 가능
      페이스북, 인스타그램 등 간단한 데이터 위주 

3. 강한strict 스키마 vs 자유로운 스키마
  SQL 
    명확하게 정의된 스키마, 데이터 무결성 보장
    일관성 중시, 명시적 정의, 인덱스를 걸게됨 트랜잭션 단위
    ACID(원자성, 일관성, 고립성, 지속성)는 데이터베이스 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질을 가리키는 약어 (Atomicity, Consistency, Isolation, Durability)
  NOSQL
    동시성 중시 (가용성,분할용인)
    데이터 중복을 계속 업데이트 해야 함
    데이터가 여러 컬렉션에 중복되어 있기 때문에 수정 시 모든 컬렉션에서 수행해야 함 (SQL에서는 중복 데이터가 없으므로 한번만 수행이 가능)


1)키-밸류 스토리지형 키-밸류형: Redis, memcached, Oracle, Coherence,
2)열 지향 와이드 컬럼 스토어: Cassandra, HBASE, Cloud Database
3) 문서형: MongoDB, Couchbase, MarkLogic, PostgreSQL, MySQL, DynamicDB MS-DocumentDB
4) 그래프형: Neo4j

예제
{
    "users": {
        "chulsu12": {
            "name": "김 철수",
            "contacts": { "minji23": true, },
        },
        "minji23": { ... },
        "hodong34": { ... },
        "me": {
           "name": "김 철수",
            "contacts": { "minji23": true, },
         },

    }
}

{
 _id: POST_ID,
 title: POST_TITLE,
 content: POST_CONTENT,
 username: POST_WRITER,
 tags: [ TAG1, TAG2, TAG3 ],
 time: POST_TIME
 comments: [
 { 
 username: COMMENT_WRITER,
 mesage: COMMENT_MESSAGE,
 time: COMMENT_TIME
 },
 { 
 username: COMMENT_WRITER,
 mesage: COMMENT_MESSAGE,
 time: COMMENT_TIME
 }
 ]
}

db.nettuts.insert({
    first: 'matthew',
    last: 'setter',
    dob: '21/04/1978',
    gender: 'm',
    hair_colour: 'brown',
    occupation: 'developer',
    nationality: 'australian'
});

db.nettuts.find({gender: 'm', $or: [{nationality: 'english'}, {nationality: 'american'}]}).sort({nationality: +1}).limit(10).skip(0);

db.nettuts.update({first: 'james', last: 'caan'}, {$set: {hair_colour: 'brown'}});

db.nettuts.remove({first: 'james', last: 'caan'});


https://www.fun-coding.org/mongodb_basic4.html

==================================

MYSQL과  POSTGRESQL
https://yahwang.github.io/posts/mysql-vs-postgres

1. 데이터베이스 구조
  MySQL : database -> table
  PostgreSQL : database -> schema -> table  

2. MySQL은 AUTO_INCREMENT 속성 / PostgreSQL은 serial 타입으로 지정

3. PostgreSQL 은 정수 / 정수를 정수로 계산한다. -> 소수 계산시 타입 캐스트 
MySQL은 정수(Integer)타입으로 변환 시 SIGNED(-포함) 혹은 UNSIGNED 타입을 요구한다.
∆
4. PostgreSQL은 오류를 바로 나타내는 반면, MySQL은 값을 0으로 바꿔버려서 주의가 필요하다.

5. MySQL 은 문자열 비교 시 대소문자 구분하지 않음. (like 연산자 포함)

6. 작은 따옴표(single quote)는 string을 표현하고 큰 따옴표(double quotes)는 컬럼명과 테이블명 같은 identifier 네이밍에 활용된다.

7. 표준 SQL에서는 SELECT보다 GROUP BY, HAVING 연산이 먼저 수행한다. ( the logical order of processing )
  그래서, ALIAS를 허용하지 않는 것이 원칙이다. 그러나, GROUP BY 절에서는 둘 다 ALIAS를 사용할 수 있다.
  단, HAVING 절은 MySQL만 사용 가능하다. ( MySQL에서는 HAVING 절의 ALIAS가 필수인 듯 )

MYSQL 전용함수 
  IF 함수
  CASE WHEN 대신 SELECT 절에 활용 가능 ( 쿼리문이 간결해지는 효과 )
  -- MySQL에만 IF문이 존재
  SELECT IF(5-3 > 0, 'TRUE', 'FALSE');
  SELECT IFNULL(NULL, 'IS NULL');

POSTGRESQL 전용 
  SELECT COALESCE(NULL, 'IS NULL');
 



