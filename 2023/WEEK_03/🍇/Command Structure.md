### 3-2. 명령어의 구조

![command structure]()

- 연산 코드
  - 데이터 전송
  - 산술/논리 연산
  - 제어 흐름 변경
  - 입출력 제어


- 주소 지정 방식
  - **즉시 주소 지정** : 오퍼랜드 필드에 <u>데이터 명시</u> 
    - 장점 : 메모리나 레지스터로 찾는 과정이 없어서 <u>가장 빠름</u>
    - 단점 : 표현할 수 있는 데이터의 크기 작아짐
  - **직접 주소 지정** : 오퍼랜드 필드에 유효 <u>주소 명시</u>
    - 장점 : 즉시 주소보다 더 많은 데이터를 표현할 수 있음 
    - 단점 : 오퍼랜드 필드의 길이가 연산 코드 길이만큼 짧아져서 표현할 수 있는 유효 주소에 제한이 생김
  - **간접 주소 지정** : 오퍼랜드 필드에 유효 <u>주소의 주소</u>를 명시
    - 장점 :  표현할 수 있는 유효 주소의 범위가 넓어짐
    -  단점 : <u>메모리에 두 번 접근</u>해야 하므로 느림
  - **레지스터 직접 주소 지정** : 오퍼랜드 필드에 사용할 데이터를 저장한 레지스터를 저장함
    - 장점 : <u>메모리에 접근하는 방법보다 빠름</u>
    - 단점 : 표현할 수 있는 레지스터 크기에 제한이 생김
  - **레지스터 간접 주소 지정** : 연산에 사용할 데이터는 메모리에 저장하고 오퍼랜드 필드에는 유효 <u>주소를 저장함</u>
    - 장점 : 메모리에 한 번 접근해서 다른 방법들보다 <u>빠름</u>

  ![Direct Mode]()


- 예제

  ```
   LDI 100, R1; R1 ← 100
   레지스터 R1을 데이터 100으로 초기화한다.(즉시 주소)
   
   LDA 600; AC ← M[600]
   M[600]을 AC로 적재한다. (직접 주소)
  ```

  <hr>

- **스택(Stack)** : 한 쪽 끝이 막혀있는 자료구조. 먼저 들어온 자료가 가장 마지막에 나오는 구조로 <u>LIFO(Last In First Out)</u> 
  - 활용 : 브라우저 뒤로가기, 실행 취소, 역순 문자열 출력, 수식의 괄호 검사 등

- **큐(Queue)** : 양쪽이 뚫려 있는 자료구조. 먼저 들어온 자료가 가장 먼저 나오는 구조로 <u>FIFO(First In First Out)</u> 
  - 활용 : (입력된 순서에 따라 처리)프로세스 관리, 캐시 구현 등
