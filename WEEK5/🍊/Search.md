# 탐색
- 같은 형태의 한 개 이상의 자료들이 모여 있는 집합에서 특정 자료를 찾는 모든 작업
- 탐색할 자료가 저장되어 있는 구조를 먼저 파악하는 것이 중요

>## 탐색기반설계
- 주어진 문제에서 주어진 데이터를 특성에 맞도록 구조화하고 이 자료를 적절한 방법으로 탐색해 나가면서 원하는 해를 찾는 알고리즘 설계법
- 전체를 탐색하는 전체탐색법과 탐색할 영역을 적절한 방법으로 배제하여 탐색의 효율을 높이는 부분탐색법이 있다.

>### 탐색이 되는 구조
1. 선형구조 : 배열이나 연결리스트로 표현될 수 있는 구조
2. 비선형구조 : 트리나 그래프의 형태로 표현되는 구조

[참조](https://huiyu.tistory.com/entry/%ED%83%90%EC%83%89%EA%B8%B0%EB%B0%98-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%84%A4%EA%B3%841%EC%84%A0%ED%98%95%EA%B5%AC%EC%A1%B0%ED%83%90%EC%83%89)


- - -
<br>

# 파이썬 (), [], {}
1. Array : [ ]
2. Tuple : ( )
3. Dictionary : { }

[참조](https://hashcode.co.kr/questions/4118/%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%99%80-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%A0-%EA%B3%B3)


- - -
<br>

# 백트래킹
> 모든 경우의 수를 전부 고려하는 알고리즘 상태공간을 트리로 나타낼 수 있을 때 적합한 방식이다. 일종의 트리 탐색 알고리즘이라고 봐도 된다. 방식에 따라서 깊이우선탐색(Depth First Search. DFS)과 너비우선탐색(Breadth First Search. BFS). 모든 경우의 수를 고려해야 하는 문제라면, DFS가 낫다. BFS로도 구현이 물론 가능하지만, BFS로 구현했다간 큐의 크기가 커진다. 심지어 속도도 똑같다. 따라서 경우의 수 구하기는 일반적으로 DFS가 편리하다. 대다수의 문제들은 DFS를 써도 일단 답은 나온다.

[참조](https://fomaios.tistory.com/entry/Algorithm-%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9Backtracking%EC%9D%B4%EB%9E%80)