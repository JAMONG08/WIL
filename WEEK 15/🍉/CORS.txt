CORS
- CORS(Cross-Origin Resource Sharing
- 교차 출처 리소스 공유 정책
- (엇갈린) 다른 출처를 의미하는 것으로 보면 된다.

    ₩₩₩
    Access to fetch at ‘https://myhompage.com’ from origin ‘http://localhost:3000’ has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header 
    is present on the requested resource. If an opaque response serves your needs, set the request’s mode to ‘no-cors’ to fetch the resource with CORS disabled.

    -> 번역
    'https://myhomepage.com'에서 'https://localhost:3000' 출처로 가져올 수 있는 액세스가 CORS 정책에 의해 차단되었습니다. 요청된 리소스에 'Access-Control-Allow-Origin' 헤더가 없습니다.
    불투명한 응답이 필요에 적합한 경우, 요청 모드를 'no-cors'로 설정하여 CORS가 비활성화된 리소스를 가져오십시오.
    ₩₩₩₩


특징
    1. <img>, <video>, <script>, <link> 태그 → 기본적으로 Cross-Origin 정책을 지원함
        <link> 태그의 href 에서 다른 사이트의 .css 리소스에 접근하는 것이 가능
        <img> 태그의 src 에서 다른 사이트의 .png, .jpg 등의 리소스에 접근하는 것이 가능
        <script> 태그의 src 에서 다른 사이트의 .js 리소스에 접근하는 것이 가능 (type="module" 속성은 제외)

        <link crossorigin rel="stylesheet" href="…" />
        <link crossorigin rel="preload" as="font" href="…" />
        <script crossorigin src="…"></script>
        <img crossorigin src="…" />


    2. XMLHttpRequest, Fetch API → 기본적으로 Same-Origin 정책을 따름
        다른 도메인에게 ajax 요청 API 호출시 서로 다른 도메인에 대한 요청을 제한
        브라우저는 기본적으로 하나의 서버 연결만 허용하도록 설정되어 있음
        console.log(location.origin);

어떻게 확인?
    Origin : Protocol + Host + Port
        - 주소를 보고 파악한다 
        - 같은 출저와 다른 출처 구분 기준
        Protocol(Scheme), Host, Port 이 3가지만 동일하다면 동일 출처로 판단한다.
            https://www.domain.com:3000/about	O	프로토콜, 호스트, 포트 번호 동일
            https://www.domain.com:3000/about?username=inpa	O	프로토콜, 호스트, 포트 번호 동일
            http://www.domain.com:3000	X	프로토콜 다름 (http ≠ https)
            https://www.another.co.kr:3000	X	호스트 다름
            https://www.domain.com:8888	X	포트 번호 다름
            https://www.domain.com	X	포트 번호 다름 (80 ≠ 3000)

    
    SOP(Same-Origin Policy) - 동일 출처 정책
        - 왜 안돼? 내부망 아이피 포트를 가져오거나 사용자 브라우저를 프록시처럼 악용할 수 있음 
        - CSRF(Cross-Site Request Forgery)나 XSS(Cross-Site Scripting)


과정 
    1.HTTP요청의 헤더에 Origin을 담아 전달
    2. 서버는 응답헤더에 Access-Control-Allow-Origin을 담아 클라이언트로 전달
    3. 서버가 이 요청에 대한 응답을 할 때 응답 헤더에 Access-Control-Allow-Origin이라는 필드를 추가하고 값으로 '이 리소스를 접근하는 것이 허용된 출처'를 내려보냄
    4. 클라이언트에서 자신이 보냈던 요청의 Origin과 서버가 보내준 Access-Control-Allow-Origin을 비교
    5. 응답을 받은 브라우저는 자신이 보냈던 요청의 Origin과 서버가 보내준 응답의 Access-Control-Allow-Origin을 비교해본 후 차단할지 말지를 결정
    6. 유효하지 않다면 그 응답을 사용하지 않고 버린다. (CORS 에러 !!)


    서버가 헤더 정보를 덜 줌
    브라우저는 에러! 서버는 정상 응답했다고 뜸 = 응답 데이터는 멀쩡
    + 브라우저가 정책으로 차단을 한다는 말은, 브라우저를 통하지 않고 서버 간에 통신을 할때는 정책이 적용되지 않음(프록시)


해결방법
    - 서버에서 Access-Control-Allow-Origin 헤더에 허용할 출처를 기재해서 클라이언트에 응답
    - 클라이언트에서 미리 자바스크립트로 origin 헤더값을 위조하면 되지 않을까 싶지만, 브라우저에서 이를 감지하여 차단함
    
    1. CORS 확장프로그램 추가 
        https://chrome.google.com/webstore/detail/allow-cors-access-control/lhobafahddgcelffkeicbaginigeejlf
    2. 프록시 사이트 사용 
    3. 서버 설정 추가 
        <Directory /var/www/> 
                Options Indexes FollowSymLinks 
                AllowOverride all 
                Require all granted 
                Header set Access-Control-Allow-Origin "*" 
        </Directory>

        VirualHost
        <IfModule mod_headers.c>
            Header set Access-Control-Allow-Origin "*"
        </IfModule>



예비 요청 (Preflight Request)

사실 브라우저는 요청을 보낼때 한번에 바로 보내지않고, 먼저 예비 요청을 보내 서버와 잘 통신되는지 확인한 후 본 요청을 보낸다. 
즉, 예비 요청의 역할은 본 요청을 보내기 전에 브라우저 스스로 안전한 요청인지 미리 확인하는 것이다.
이때 브라우저가 예비요청을 보내는 것을 Preflight라고 부르며, 이 예비요청의 HTTP 메소드를 GET이나 POST가 아닌 OPTIONS라는 요청이 사용된다는 것이 특징이

바스크립트의 fetch() 메서드를 통해 리소스를 받아오려고 한다.
브라우저는 서버로 HTTP OPTIONS 메소드로 예비 요청(Preflight)을 먼저 보낸다.
Origin 헤더에 자신의 출처를 넣는다.
Access-Control-Request-Method 헤더에 실제 요청에 사용할 메소드를 설정한다.
Access-Control-Request-Headers 헤더에 실제 요청에 사용할 헤더들을 설정한다.
서버는 이 예비 요청에 대한 응답으로 어떤 것을 허용하고 어떤것을 금지하고 있는지에 대한 헤더 정보를 담아서 브라우저로 보내준다.
Access-Control-Allow-Origin 헤더에 허용되는 Origin들의 목록을 설정한다.
Access-Control-Allow-Methods 헤더에 허용되는 메소드들의 목록을 설정한다.
Access-Control-Allow-Headers 헤더에 허용되는 헤더들의 목록을 설정한다.
Access-Control-Max-Age 헤더에 해당 예비 요청이 브라우저에 캐시 될 수 있는 시간을 초 단위로 설정한다.

이후 브라우저는 보낸 요청과 서버가 응답해준 정책을 비교하여, 해당 요청이 안전한지 확인하고 본 요청을 보내게 된다.
서버가 본 요청에 대한 응답을 하면 최종적으로 이 응답 데이터를 자바스립트로 넘겨준다.


단순 요청 (Simple Request)

단순 요청은 말그대로 예비 요청(Prefilght)을 생략하고 바로 서버에 직행으로 본 요청을 보낸 후, 서버가 이에 대한 응답의 헤더에 Access-Control-Allow-Origin 헤더를 보내주면 브라우저가 CORS정책 위반 여부를 검사하는
요청의 메소드는 GET, HEAD, POST 중 하나여야 한다.
Accept, Accept-Language, Content-Language, Content-Type, DPR, Downlink, Save-Data, Viewport-Width, Width 헤더일 경우 에만 적용된다.
Content-Type 헤더가 application/x-www-form-urlencoded, multipart/form-data, text/plain중 하나여야한다. 아닐 경우 예비 요청으로 동작된다.


인증된 요청 (Credentialed Request)

인증된 요청은 클라이언트에서 서버에게 자격 인증 정보(Credential)를 실어 요청할때 사용되는 요청이다.
여기서 말하는 자격 인증 정보란 세션 ID가 저장되어있는 쿠키(Cookie) 혹은 Authorization 헤더에 설정하는 토큰 값 등을 일컫는다.
즉, 클라이언트에서 일반적인 JSON 데이터 외에도 쿠키 같은 인증 정보를 포함해서 다른 출처의 서버로 전달할때 CORS의 세가지 요청중 하나인 인증된 요청으로 동작된다는 말이며, 이는 기존의 단순 요청이나 예비 요청과는 살짝 다른 인증 형태로 통신하게 된다.
 credentials

same-origin(기본값)	같은 출처 간 요청에만 인증 정보를 담을 수 있다.
include	모든 요청에 인증 정보를 담을 수 있다.
omit	모든 요청에 인증 정보를 담지 않는다.

응답 헤더의 Access-Control-Allow-Credentials 항목을 true로 설정해야 한다.
응답 헤더의 Access-Control-Allow-Origin 의 값에 와일드카드 문자("*")는 사용할 수 없다.
응답 헤더의 Access-Control-Allow-Methods 의 값에 와일드카드 문자("*")는 사용할 수 없다.
응답 헤더의 Access-Control-Allow-Headers 의 값에 와일드카드 문자("*")는 사용할 수 없다.


https://chuckchoiboi.github.io/cors-tutorial/




===============================================
https://pjc91.tistory.com/55